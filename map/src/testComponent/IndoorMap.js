// import React, { useEffect, useRef } from 'react';
// import L from 'leaflet';
// import 'leaflet/dist/leaflet.css';
// import 'leaflet-indoor'; // Import the leaflet-indoor plugin

// const IndoorMap = ({ jsonData }) => {
//     const mapRef = useRef(null); // Ref for the map container
//     const mapInstance = useRef(null); // Ref for the actual Leaflet map instance

//     useEffect(() => {
//         // Initialize the map only once when the component mounts
//         if (!mapInstance.current) {
//             // Initialize map if it's not already initialized
//             mapInstance.current = L.map(mapRef.current, {
//                 center: [49.4186, 8.6770],
//                 zoom: 19,
//                 maxZoom: 22,
//             });

//             const osmUrl = '//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
//             const osmLayer = new L.TileLayer(osmUrl, {
//                 maxZoom: 22,
//                 attribution: "Map data &copy; OpenStreetMap contributors",
//             });

//             mapInstance.current.addLayer(osmLayer);
//         }

//         // When map is initialized and jsonData is available, add indoor data
//         if (mapInstance.current && jsonData) {
//             // Initialize the indoor layer using L.Indoor
//             const indoorLayer = new L.Indoor(jsonData, {
//                 getLevel: function (feature) {
//                     if (feature.properties.relations.length === 0) return null;
//                     return feature.properties.relations[0].reltags.level;
//                 },
//                 onEachFeature: function (feature, layer) {
//                     layer.bindPopup(JSON.stringify(feature.properties, null, 4));
//                 },
//                 style: function (feature) {
//                     let fillColor = 'white';
//                     if (feature.properties.tags.buildingpart === 'corridor') {
//                         fillColor = '#169EC6';
//                     } else if (feature.properties.tags.buildingpart === 'verticalpassage') {
//                         fillColor = '#0A485B';
//                     } else if (feature.properties.tags.buildingpart === 'hall') {
//                         fillColor = '#B0E57C';
//                     }

//                     return {
//                         fillColor: fillColor,
//                         weight: 1,
//                         color: '#666',
//                         fillOpacity: 0.7,
//                     };
//                 },
//             });

//             indoorLayer.setLevel("0");
//             indoorLayer.addTo(mapInstance.current);

//             const levelControl = new L.Control.Level({
//                 level: "0",
//                 levels: indoorLayer.getLevels(),
//             });

//             levelControl.addEventListener('levelchange', () => {
//                 indoorLayer.setLevel(levelControl._currentLevel);
//             });
//             levelControl.addTo(mapInstance.current);

//             const legend = L.control({ position: 'topright' });
//             legend.onAdd = function () {
//                 const div = L.DomUtil.create('div', 'info legend');
//                 div.innerHTML = `
//           <strong>Map Information</strong><br />
//           This is a custom indoor map. Use the level selector at the bottom to switch floors.
//         `;
//                 return div;
//             };
//             legend.addTo(mapInstance.current);
//         }

//         // Cleanup map when component unmounts
//         return () => {
//             if (mapInstance.current) {
//                 mapInstance.current.remove();
//             }
//         };
//     }, [jsonData]); // Triggered when jsonData changes

//     return <div ref={mapRef} style={{ height: '100vh', width: '100%' }} />;
// };

// export default IndoorMap;



/// working for map

// import React, { useState, useEffect } from 'react';
// import { MapContainer, TileLayer, Polygon, Marker, Polyline, Tooltip } from 'react-leaflet';
// import 'leaflet/dist/leaflet.css';
// import L from 'leaflet';

// const IndoorMap = ({ data }) => {
//     const [mapData, setMapData] = useState([]);

//     useEffect(() => {
//         if (!data || !data.features) return;

//         const processedData = data.features.map((feature) => {
//             const { geometry, properties } = feature;
//             const coords = geometry.coordinates;

//             return {
//                 id: feature.id,
//                 type: properties.tags?.buildingpart || "unknown",
//                 name: properties.tags?.name || "Unnamed",
//                 height: parseFloat(properties.tags?.height) || 0,
//                 width: parseFloat(properties.tags?.width) || 0,
//                 geometryType: geometry.type,
//                 coordinates:
//                     geometry.type === "Polygon" ? coords[0].map(([lng, lat]) => [lat, lng]) :
//                         geometry.type === "LineString" ? coords.map(([lng, lat]) => [lat, lng]) :
//                             geometry.type === "Point" ? [coords[1], coords[0]] : null,
//             };
//         }).filter((feature) => feature.coordinates);

//         setMapData(processedData);
//     }, [data]);

//     const getColorByType = (type) => {
//         switch (type) {
//             case "room": return "#f5e6b1"; // Light beige for rooms
//             case "hall": return "#d4c7a1"; // Light brown for halls
//             case "corridor": return "#e0e0e0"; // Light grey for corridors
//             case "verticalpassage": return "#d9b38c"; // Light tan for vertical passages
//             case "shell": return "#c0c0c0"; // Light grey for shell/outer areas
//             default: return "#8fc0e9"; // Light blue for unknown types like doors
//         }
//     };

//     return (
//         <MapContainer center={[49.4185603, 8.677043]} zoom={18} style={{ height: "80vh", width: "100%" }}>


//             {mapData.map((feature) => {
//                 const color = getColorByType(feature.type);

//                 if (feature.geometryType === "Polygon") {
//                     return (
//                         <Polygon
//                             key={feature.id}
//                             positions={feature.coordinates}
//                             color="grey" // Border color for rooms and corridors
//                             fillColor={color} // Fill color based on type
//                             fillOpacity={0.7}
//                             weight={1} // Border thickness
//                         >
//                             <Tooltip>
//                                 <div>
//                                     <h3>{feature.name}</h3>
//                                     <p>Type: {feature.type}</p>
//                                     <p>Height: {feature.height}m</p>
//                                 </div>
//                             </Tooltip>
//                         </Polygon>
//                     );
//                 } else if (feature.geometryType === "LineString") {
//                     return (
//                         <Polyline
//                             key={feature.id}
//                             positions={feature.coordinates}
//                             color="#3498db"
//                             weight={4} // Thicker lines for pathways
//                         >
//                             <Tooltip>
//                                 <div>
//                                     <h3>{feature.name}</h3>
//                                     <p>Type: {feature.type}</p>
//                                     <p>Height: {feature.height}m</p>
//                                 </div>
//                             </Tooltip>
//                         </Polyline>
//                     );
//                 } else if (feature.geometryType === "Point") {
//                     return (
//                         <Marker
//                             key={feature.id}
//                             position={feature.coordinates}
//                             icon={L.divIcon({
//                                 className: 'custom-icon',
//                                 html: `<div style="background-color:${color}; width:8px; height:4px; "></div>`
//                             })}
//                         >
//                             <Tooltip>
//                                 <div>
//                                     <h3>{feature.name}</h3>
//                                     <p>Type: {feature.type}</p>
//                                     <p>Height: {feature.height}m</p>
//                                     <p>Width: {feature.width}m</p>
//                                 </div>
//                             </Tooltip>
//                         </Marker>
//                     );
//                 }
//                 return null;
//             })}
//         </MapContainer>
//     );
// };


// export default IndoorMap;



// moving person added 
// import React, { useState, useEffect } from "react";
// import { MapContainer, Polygon, Polyline, Marker, Tooltip, useMap } from "react-leaflet";
// import L from "leaflet";

// const IndoorMap = ({ data }) => {
//     const [mapData, setMapData] = useState([]);
//     const [personPosition, setPersonPosition] = useState(null); // State for personâ€™s position
//     const [path, setPath] = useState([]); // State for the movement path of the person

//     useEffect(() => {
//         if (!data || !data.features) return;

//         const processedData = data.features.map((feature) => {
//             const { geometry, properties } = feature;
//             const coords = geometry.coordinates;

//             return {
//                 id: feature.id,
//                 type: properties.tags?.buildingpart || "unknown",
//                 name: properties.tags?.name || "Unnamed",
//                 height: parseFloat(properties.tags?.height) || 0,
//                 width: parseFloat(properties.tags?.width) || 0,
//                 geometryType: geometry.type,
//                 coordinates:
//                     geometry.type === "Polygon" ? coords[0].map(([lng, lat]) => [lat, lng]) :
//                         geometry.type === "LineString" ? coords.map(([lng, lat]) => [lat, lng]) :
//                             geometry.type === "Point" ? [coords[1], coords[0]] : null,
//             };
//         }).filter((feature) => feature.coordinates);

//         setMapData(processedData);

//         // Set initial person position and path for movement
//         const initialPosition = [49.4185603, 8.677043];
//         const destinationPosition = [49.4195603, 8.678043]; // Example endpoint
//         setPersonPosition(initialPosition);
//         setPath([initialPosition, destinationPosition]); // Path from start to end

//     }, [data]);

//     useEffect(() => {
//         if (path.length < 2) return;

//         // Animate the person along the path
//         const movePerson = () => {
//             let index = 0;

//             const interval = setInterval(() => {
//                 if (index >= path.length - 1) {
//                     clearInterval(interval);
//                 } else {
//                     setPersonPosition(path[index]);
//                     index += 1;
//                 }
//             }, 500); // Adjust speed as needed

//             return () => clearInterval(interval);
//         };

//         movePerson();
//     }, [path]);

//     const getColorByType = (type) => {
//         switch (type) {
//             case "room": return "#f5e6b1"; // Light beige for rooms
//             case "hall": return "#d4c7a1"; // Light brown for halls
//             case "corridor": return "#e0e0e0"; // Light grey for corridors
//             case "verticalpassage": return "#d9b38c"; // Light tan for vertical passages
//             case "shell": return "#c0c0c0"; // Light grey for shell/outer areas
//             default: return "#8fc0e9"; // Light blue for unknown types like doors
//         }
//     };

//     return (
//         <MapContainer center={[49.4185603, 8.677043]} zoom={18} style={{ height: "80vh", width: "100%" }}>
//             {mapData.map((feature) => {
//                 const color = getColorByType(feature.type);

//                 if (feature.geometryType === "Polygon") {
//                     return (
//                         <Polygon
//                             key={feature.id}
//                             positions={feature.coordinates}
//                             color="grey"
//                             fillColor={color}
//                             fillOpacity={0.7}
//                             weight={1}
//                         >
//                             <Tooltip>
//                                 <div>
//                                     <h3>{feature.name}</h3>
//                                     <p>Type: {feature.type}</p>
//                                     <p>Height: {feature.height}m</p>
//                                 </div>
//                             </Tooltip>
//                         </Polygon>
//                     );
//                 } else if (feature.geometryType === "LineString") {
//                     return (
//                         <Polyline
//                             key={feature.id}
//                             positions={feature.coordinates}
//                             color="#3498db"
//                             weight={4}
//                         >
//                             <Tooltip>
//                                 <div>
//                                     <h3>{feature.name}</h3>
//                                     <p>Type: {feature.type}</p>
//                                     <p>Height: {feature.height}m</p>
//                                 </div>
//                             </Tooltip>
//                         </Polyline>
//                     );
//                 } else if (feature.geometryType === "Point") {
//                     return (
//                         <Marker
//                             key={feature.id}
//                             position={feature.coordinates}
//                             icon={L.divIcon({
//                                 className: 'custom-icon',
//                                 html: `<div style="background-color:${color}; width:8px; height:4px;"></div>`
//                             })}
//                         >
//                             <Tooltip>
//                                 <div>
//                                     <h3>{feature.name}</h3>
//                                     <p>Type: {feature.type}</p>
//                                     <p>Height: {feature.height}m</p>
//                                     <p>Width: {feature.width}m</p>
//                                 </div>
//                             </Tooltip>
//                         </Marker>
//                     );
//                 }
//                 return null;
//             })}

//             {/* Marker to represent the moving person */}
//             {personPosition && (
//                 <Marker
//                     position={personPosition}
//                     icon={L.divIcon({
//                         className: 'person-icon',
//                         html: `<div style="background-color:red; width:10px; height:10px; border-radius:50%;"></div>`
//                     })}
//                 >
//                     <Tooltip>Moving Person</Tooltip>
//                 </Marker>
//             )}
//         </MapContainer>
//     );
// };

// export default IndoorMap;




// with floors 
import React, { useState, useEffect } from 'react';
import { MapContainer, Polygon, Polyline, Marker, Tooltip, Circle } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { renderCorridorMiddleLines } from './utility';

const IndoorMap = ({ data }) => {
    const [mapData, setMapData] = useState([]);
    const [floors, setFloors] = useState([]);
    const [selectedFloor, setSelectedFloor] = useState(null);
    const [searchQuery, setSearchQuery] = useState('');
    const [markerPositions, setMarkerPositions] = useState([]);
    const [srcMarker, setSrcMarker] = useState(null);
    const [destMarker, setDestMarker] = useState(null);
    const [pathCoordinates, setPathCoordinates] = useState([]);
    const [movingMarkerPosition, setMovingMarkerPosition] = useState(null);
    const [currentPathIndex, setCurrentPathIndex] = useState(0);
    const [cooridorPath, setCooridorPath] = useState([])

    let testdata = {
        coordinates: [
            [49.4184995, 8.6767686, 49.4184997, 8.6767687],
            [49.4184995, 8.6767687, 49.4184997, 8.6767689],
            [49.4184995, 8.6767689, 49.4184997, 8.6767691],
            [49.4184995, 8.6767691, 49.4184997, 8.6767699],
            [49.4184995, 8.6767699, 49.4184997, 8.6767803],
            [49.4184995, 8.6767803, 49.4184997, 8.676792],
            [49.4184995, 8.676792, 49.4184997, 8.6767921],
            [49.4184995, 8.6767921, 49.4184997, 8.6767922],
            [49.4184995, 8.6767922, 49.4184997, 8.6767923],
            [49.4184995, 8.6767923, 49.4184997, 8.6769047],
            [49.4184995, 8.6769047, 49.4184997, 8.6769152],
            [49.4184995, 8.6769152, 49.4184997, 8.6769297],
            [49.4184995, 8.6769297, 49.4184997, 8.6769648],
            [49.4184995, 8.6769648, 49.4184997, 8.6769663],
            [49.4184995, 8.6769663, 49.4184997, 8.6769928],
            [49.4184995, 8.6769928, 49.4184997, 8.6769931],
            [49.4184995, 8.6769931, 49.4184997, 8.677017],
            [49.4184995, 8.677017, 49.4184997, 8.6770397],
            [49.4184997, 8.6767686, 49.4185079, 8.6767687],
            [49.4184997, 8.6767687, 49.4185079, 8.6767689],
            [49.4184997, 8.6767689, 49.4185079, 8.6767691],
            [49.4184997, 8.6767691, 49.4185079, 8.6767699],
            [49.4184997, 8.6767699, 49.4185079, 8.6767803],
            [49.4184997, 8.6767803, 49.4185079, 8.676792],
            [49.4184997, 8.676792, 49.4185079, 8.6767921],
            [49.4184997, 8.6767921, 49.4185079, 8.6767922],
            [49.4184997, 8.6767922, 49.4185079, 8.6767923],
            [49.4184997, 8.6767923, 49.4185079, 8.6769047],
            [49.4184997, 8.6769047, 49.4185079, 8.6769152],
            [49.4184997, 8.6769152, 49.4185079, 8.6769297],
            [49.4184997, 8.6769297, 49.4185079, 8.6769648],
            [49.4184997, 8.6769648, 49.4185079, 8.6769663],
            [49.4184997, 8.6769663, 49.4185079, 8.6769928],
            [49.4184997, 8.6769928, 49.4185079, 8.6769931],
            [49.4184997, 8.6769931, 49.4185079, 8.677017],
            [49.4184997, 8.677017, 49.4185079, 8.6770397],
            [49.4185079, 8.6767686, 49.4185197, 8.6767687],
            [49.4185079, 8.6767687, 49.4185197, 8.6767689],
            [49.4185079, 8.6767689, 49.4185197, 8.6767691],
            [49.4185079, 8.6767691, 49.4185197, 8.6767699],
            [49.4185079, 8.6767699, 49.4185197, 8.6767803],
            [49.4185079, 8.6767803, 49.4185197, 8.676792],
            [49.4185079, 8.676792, 49.4185197, 8.6767921],
            [49.4185079, 8.6767921, 49.4185197, 8.6767922],
            [49.4185079, 8.6767922, 49.4185197, 8.6767923],
            [49.4185079, 8.6767923, 49.4185197, 8.6769047],
            [49.4185079, 8.6769047, 49.4185197, 8.6769152],
            [49.4185079, 8.6769152, 49.4185197, 8.6769297],
            [49.4185079, 8.6769297, 49.4185197, 8.6769648],
            [49.4185079, 8.6769648, 49.4185197, 8.6769663],
            [49.4185079, 8.6769663, 49.4185197, 8.6769928],
            [49.4185079, 8.6769928, 49.4185197, 8.6769931],
            [49.4185079, 8.6769931, 49.4185197, 8.677017],
            [49.4185079, 8.677017, 49.4185197, 8.6770397],
            [49.4185197, 8.6767686, 49.4185198, 8.6767687],
            [49.4185197, 8.6767687, 49.4185198, 8.6767689],
            [49.4185197, 8.6767689, 49.4185198, 8.6767691],
            [49.4185197, 8.6767691, 49.4185198, 8.6767699],
            [49.4185197, 8.6767699, 49.4185198, 8.6767803],
            [49.4185197, 8.6767803, 49.4185198, 8.676792],
            [49.4185197, 8.676792, 49.4185198, 8.6767921],
            [49.4185197, 8.6767921, 49.4185198, 8.6767922],
            [49.4185197, 8.6767922, 49.4185198, 8.6767923],
            [49.4185197, 8.6767923, 49.4185198, 8.6769047],
            [49.4185197, 8.6769047, 49.4185198, 8.6769152],
            [49.4185197, 8.6769152, 49.4185198, 8.6769297],
            [49.4185197, 8.6769297, 49.4185198, 8.6769648],
            [49.4185197, 8.6769648, 49.4185198, 8.6769663],
            [49.4185197, 8.6769663, 49.4185198, 8.6769928],
            [49.4185197, 8.6769928, 49.4185198, 8.6769931],
            [49.4185197, 8.6769931, 49.4185198, 8.677017],
            [49.4185197, 8.677017, 49.4185198, 8.6770397],
            [49.4185198, 8.6767686, 49.4185315, 8.6767687],
            [49.4185198, 8.6767687, 49.4185315, 8.6767689],
            [49.4185198, 8.6767689, 49.4185315, 8.6767691],
            [49.4185198, 8.6767691, 49.4185315, 8.6767699],
            [49.4185198, 8.6767699, 49.4185315, 8.6767803],
            [49.4185198, 8.6767803, 49.4185315, 8.676792],
            [49.4185198, 8.676792, 49.4185315, 8.6767921],
            [49.4185198, 8.6767921, 49.4185315, 8.6767922],
            [49.4185198, 8.6767922, 49.4185315, 8.6767923],
            [49.4185198, 8.6767923, 49.4185315, 8.6769047],
            [49.4185198, 8.6769047, 49.4185315, 8.6769152],
            [49.4185198, 8.6769152, 49.4185315, 8.6769297],
            [49.4185198, 8.6769297, 49.4185315, 8.6769648],
            [49.4185198, 8.6769648, 49.4185315, 8.6769663],
            [49.4185198, 8.6769663, 49.4185315, 8.6769928],
            [49.4185198, 8.6769928, 49.4185315, 8.6769931],
            [49.4185198, 8.6769931, 49.4185315, 8.677017],
            [49.4185198, 8.677017, 49.4185315, 8.6770397],
            [49.4185315, 8.6767686, 49.4185393, 8.6767687],
            [49.4185315, 8.6767687, 49.4185393, 8.6767689],
            [49.4185315, 8.6767689, 49.4185393, 8.6767691],
            [49.4185315, 8.6767691, 49.4185393, 8.6767699],
            [49.4185315, 8.6767699, 49.4185393, 8.6767803],
            [49.4185315, 8.6767803, 49.4185393, 8.676792],
            [49.4185315, 8.676792, 49.4185393, 8.6767921],
            [49.4185315, 8.6767921, 49.4185393, 8.6767922],
            [49.4185315, 8.6767922, 49.4185393, 8.6767923],
            [49.4185315, 8.6767923, 49.4185393, 8.6769047],
            [49.4185315, 8.6769047, 49.4185393, 8.6769152],
            [49.4185315, 8.6769152, 49.4185393, 8.6769297],
            [49.4185315, 8.6769297, 49.4185393, 8.6769648],
            [49.4185315, 8.6769648, 49.4185393, 8.6769663],
            [49.4185315, 8.6769663, 49.4185393, 8.6769928],
            [49.4185315, 8.6769928, 49.4185393, 8.6769931],
            [49.4185315, 8.6769931, 49.4185393, 8.677017],
            [49.4185315, 8.677017, 49.4185393, 8.6770397],
            [49.4185393, 8.6767686, 49.4185442, 8.6767687],
            [49.4185393, 8.6767687, 49.4185442, 8.6767689],
            [49.4185393, 8.6767689, 49.4185442, 8.6767691],
            [49.4185393, 8.6767691, 49.4185442, 8.6767699],
            [49.4185393, 8.6767699, 49.4185442, 8.6767803],
            [49.4185393, 8.6767803, 49.4185442, 8.676792],
            [49.4185393, 8.676792, 49.4185442, 8.6767921],
            [49.4185393, 8.6767921, 49.4185442, 8.6767922],
            [49.4185393, 8.6767922, 49.4185442, 8.6767923],
            [49.4185393, 8.6767923, 49.4185442, 8.6769047],
            [49.4185393, 8.6769047, 49.4185442, 8.6769152],
            [49.4185393, 8.6769152, 49.4185442, 8.6769297],
            [49.4185393, 8.6769297, 49.4185442, 8.6769648],
            [49.4185393, 8.6769648, 49.4185442, 8.6769663],
            [49.4185393, 8.6769663, 49.4185442, 8.6769928],
            [49.4185393, 8.6769928, 49.4185442, 8.6769931],
            [49.4185393, 8.6769931, 49.4185442, 8.677017],
            [49.4185393, 8.677017, 49.4185442, 8.6770397],
            [49.4185442, 8.6767686, 49.4185443, 8.6767687],
            [49.4185442, 8.6767687, 49.4185443, 8.6767689],
            [49.4185442, 8.6767689, 49.4185443, 8.6767691],
            [49.4185442, 8.6767691, 49.4185443, 8.6767699],
            [49.4185442, 8.6767699, 49.4185443, 8.6767803],
            [49.4185442, 8.6767803, 49.4185443, 8.676792],
            [49.4185442, 8.676792, 49.4185443, 8.6767921],
            [49.4185442, 8.6767921, 49.4185443, 8.6767922],
            [49.4185442, 8.6767922, 49.4185443, 8.6767923],
            [49.4185442, 8.6767923, 49.4185443, 8.6769047],
            [49.4185442, 8.6769047, 49.4185443, 8.6769152],
            [49.4185442, 8.6769152, 49.4185443, 8.6769297],
            [49.4185442, 8.6769297, 49.4185443, 8.6769648],
            [49.4185442, 8.6769648, 49.4185443, 8.6769663],
            [49.4185442, 8.6769663, 49.4185443, 8.6769928],
            [49.4185442, 8.6769928, 49.4185443, 8.6769931],
            [49.4185442, 8.6769931, 49.4185443, 8.677017],
            [49.4185442, 8.677017, 49.4185443, 8.6770397],
            [49.4185443, 8.6767686, 49.4185564, 8.6767687],
            [49.4185443, 8.6767687, 49.4185564, 8.6767689],
            [49.4185443, 8.6767689, 49.4185564, 8.6767691],
            [49.4185443, 8.6767691, 49.4185564, 8.6767699],
            [49.4185443, 8.6767699, 49.4185564, 8.6767803],
            [49.4185443, 8.6767803, 49.4185564, 8.676792],
            [49.4185443, 8.676792, 49.4185564, 8.6767921],
            [49.4185443, 8.6767921, 49.4185564, 8.6767922],
            [49.4185443, 8.6767922, 49.4185564, 8.6767923],
            [49.4185443, 8.6767923, 49.4185564, 8.6769047],
            [49.4185443, 8.6769047, 49.4185564, 8.6769152],
            [49.4185443, 8.6769152, 49.4185564, 8.6769297],
            [49.4185443, 8.6769297, 49.4185564, 8.6769648],
            [49.4185443, 8.6769648, 49.4185564, 8.6769663],
            [49.4185443, 8.6769663, 49.4185564, 8.6769928],
            [49.4185443, 8.6769928, 49.4185564, 8.6769931],
            [49.4185443, 8.6769931, 49.4185564, 8.677017],
            [49.4185443, 8.677017, 49.4185564, 8.6770397],
            [49.4185564, 8.6767686, 49.4185566, 8.6767687],
            [49.4185564, 8.6767687, 49.4185566, 8.6767689],
            [49.4185564, 8.6767689, 49.4185566, 8.6767691],
            [49.4185564, 8.6767691, 49.4185566, 8.6767699],
            [49.4185564, 8.6767699, 49.4185566, 8.6767803],
            [49.4185564, 8.6767803, 49.4185566, 8.676792],
            [49.4185564, 8.676792, 49.4185566, 8.6767921],
            [49.4185564, 8.6767921, 49.4185566, 8.6767922],
            [49.4185564, 8.6767922, 49.4185566, 8.6767923],
            [49.4185564, 8.6767923, 49.4185566, 8.6769047],
            [49.4185564, 8.6769047, 49.4185566, 8.6769152],
            [49.4185564, 8.6769152, 49.4185566, 8.6769297],
            [49.4185564, 8.6769297, 49.4185566, 8.6769648],
            [49.4185564, 8.6769648, 49.4185566, 8.6769663],
            [49.4185564, 8.6769663, 49.4185566, 8.6769928],
            [49.4185564, 8.6769928, 49.4185566, 8.6769931],
            [49.4185564, 8.6769931, 49.4185566, 8.677017],
            [49.4185564, 8.677017, 49.4185566, 8.6770397],
            [49.4185566, 8.6767686, 49.4185567, 8.6767687],
            [49.4185566, 8.6767687, 49.4185567, 8.6767689],
            [49.4185566, 8.6767689, 49.4185567, 8.6767691],
            [49.4185566, 8.6767691, 49.4185567, 8.6767699],
            [49.4185566, 8.6767699, 49.4185567, 8.6767803],
            [49.4185566, 8.6767803, 49.4185567, 8.676792],
            [49.4185566, 8.676792, 49.4185567, 8.6767921],
            [49.4185566, 8.6767921, 49.4185567, 8.6767922],
            [49.4185566, 8.6767922, 49.4185567, 8.6767923],
            [49.4185566, 8.6767923, 49.4185567, 8.6769047],
            [49.4185566, 8.6769047, 49.4185567, 8.6769152],
            [49.4185566, 8.6769152, 49.4185567, 8.6769297],
            [49.4185566, 8.6769297, 49.4185567, 8.6769648],
            [49.4185566, 8.6769648, 49.4185567, 8.6769663],
            [49.4185566, 8.6769663, 49.4185567, 8.6769928],
            [49.4185566, 8.6769928, 49.4185567, 8.6769931],
            [49.4185566, 8.6769931, 49.4185567, 8.677017],
            [49.4185566, 8.677017, 49.4185567, 8.6770397],
            [49.4185567, 8.6767686, 49.4185646, 8.6767687],
            [49.4185567, 8.6767687, 49.4185646, 8.6767689],
            [49.4185567, 8.6767689, 49.4185646, 8.6767691],
            [49.4185567, 8.6767691, 49.4185646, 8.6767699],
            [49.4185567, 8.6767699, 49.4185646, 8.6767803],
            [49.4185567, 8.6767803, 49.4185646, 8.676792],
            [49.4185567, 8.676792, 49.4185646, 8.6767921],
            [49.4185567, 8.6767921, 49.4185646, 8.6767922],
            [49.4185567, 8.6767922, 49.4185646, 8.6767923],
            [49.4185567, 8.6767923, 49.4185646, 8.6769047],
            [49.4185567, 8.6769047, 49.4185646, 8.6769152],
            [49.4185567, 8.6769152, 49.4185646, 8.6769297],
            [49.4185567, 8.6769297, 49.4185646, 8.6769648],
            [49.4185567, 8.6769648, 49.4185646, 8.6769663],
            [49.4185567, 8.6769663, 49.4185646, 8.6769928],
            [49.4185567, 8.6769928, 49.4185646, 8.6769931],
            [49.4185567, 8.6769931, 49.4185646, 8.677017],
            [49.4185567, 8.677017, 49.4185646, 8.6770397],
            [49.4185646, 8.6767686, 49.4185673, 8.6767687],
            [49.4185646, 8.6767687, 49.4185673, 8.6767689],
            [49.4185646, 8.6767689, 49.4185673, 8.6767691],
            [49.4185646, 8.6767691, 49.4185673, 8.6767699],
            [49.4185646, 8.6767699, 49.4185673, 8.6767803],
            [49.4185646, 8.6767803, 49.4185673, 8.676792],
            [49.4185646, 8.676792, 49.4185673, 8.6767921],
            [49.4185646, 8.6767921, 49.4185673, 8.6767922],
            [49.4185646, 8.6767922, 49.4185673, 8.6767923],
            [49.4185646, 8.6767923, 49.4185673, 8.6769047],
            [49.4185646, 8.6769047, 49.4185673, 8.6769152],
            [49.4185646, 8.6769152, 49.4185673, 8.6769297],
            [49.4185646, 8.6769297, 49.4185673, 8.6769648],
            [49.4185646, 8.6769648, 49.4185673, 8.6769663],
            [49.4185646, 8.6769663, 49.4185673, 8.6769928],
            [49.4185646, 8.6769928, 49.4185673, 8.6769931],
            [49.4185646, 8.6769931, 49.4185673, 8.677017],
            [49.4185646, 8.677017, 49.4185673, 8.6770397],
            [49.4185673, 8.6767686, 49.4185974, 8.6767687],
            [49.4185673, 8.6767687, 49.4185974, 8.6767689],
            [49.4185673, 8.6767689, 49.4185974, 8.6767691],
            [49.4185673, 8.6767691, 49.4185974, 8.6767699],
            [49.4185673, 8.6767699, 49.4185974, 8.6767803],
            [49.4185673, 8.6767803, 49.4185974, 8.676792],
            [49.4185673, 8.676792, 49.4185974, 8.6767921],
            [49.4185673, 8.6767921, 49.4185974, 8.6767922],
            [49.4185673, 8.6767922, 49.4185974, 8.6767923],
            [49.4185673, 8.6767923, 49.4185974, 8.6769047],
            [49.4185673, 8.6769047, 49.4185974, 8.6769152],
            [49.4185673, 8.6769152, 49.4185974, 8.6769297],
            [49.4185673, 8.6769297, 49.4185974, 8.6769648],
            [49.4185673, 8.6769648, 49.4185974, 8.6769663],
            [49.4185673, 8.6769663, 49.4185974, 8.6769928],
            [49.4185673, 8.6769928, 49.4185974, 8.6769931],
            [49.4185673, 8.6769931, 49.4185974, 8.677017],
            [49.4185673, 8.677017, 49.4185974, 8.6770397],
            [49.4185974, 8.6767686, 49.418602, 8.6767687],
            [49.4185974, 8.6767687, 49.418602, 8.6767689],
            [49.4185974, 8.6767689, 49.418602, 8.6767691],
            [49.4185974, 8.6767691, 49.418602, 8.6767699],
            [49.4185974, 8.6767699, 49.418602, 8.6767803],
            [49.4185974, 8.6767803, 49.418602, 8.676792],
            [49.4185974, 8.676792, 49.418602, 8.6767921],
            [49.4185974, 8.6767921, 49.418602, 8.6767922],
            [49.4185974, 8.6767922, 49.418602, 8.6767923],
            [49.4185974, 8.6767923, 49.418602, 8.6769047],
            [49.4185974, 8.6769047, 49.418602, 8.6769152],
            [49.4185974, 8.6769152, 49.418602, 8.6769297],
            [49.4185974, 8.6769297, 49.418602, 8.6769648],
            [49.4185974, 8.6769648, 49.418602, 8.6769663],
            [49.4185974, 8.6769663, 49.418602, 8.6769928],
            [49.4185974, 8.6769928, 49.418602, 8.6769931],
            [49.4185974, 8.6769931, 49.418602, 8.677017],
            [49.4185974, 8.677017, 49.418602, 8.6770397],
            [49.418602, 8.6767686, 49.418641, 8.6767687],
            [49.418602, 8.6767687, 49.418641, 8.6767689],
            [49.418602, 8.6767689, 49.418641, 8.6767691],
            [49.418602, 8.6767691, 49.418641, 8.6767699],
            [49.418602, 8.6767699, 49.418641, 8.6767803],
            [49.418602, 8.6767803, 49.418641, 8.676792],
            [49.418602, 8.676792, 49.418641, 8.6767921],
            [49.418602, 8.6767921, 49.418641, 8.6767922],
            [49.418602, 8.6767922, 49.418641, 8.6767923],
            [49.418602, 8.6767923, 49.418641, 8.6769047],
            [49.418602, 8.6769047, 49.418641, 8.6769152],
            [49.418602, 8.6769152, 49.418641, 8.6769297],
            [49.418602, 8.6769297, 49.418641, 8.6769648],
            [49.418602, 8.6769648, 49.418641, 8.6769663],
            [49.418602, 8.6769663, 49.418641, 8.6769928],
            [49.418602, 8.6769928, 49.418641, 8.6769931],
            [49.418602, 8.6769931, 49.418641, 8.677017],
            [49.418602, 8.677017, 49.418641, 8.6770397],
            [49.418641, 8.6767686, 49.4186592, 8.6767687],
            [49.418641, 8.6767687, 49.4186592, 8.6767689],
            [49.418641, 8.6767689, 49.4186592, 8.6767691],
            [49.418641, 8.6767691, 49.4186592, 8.6767699],
            [49.418641, 8.6767699, 49.4186592, 8.6767803],
            [49.418641, 8.6767803, 49.4186592, 8.676792],
            [49.418641, 8.676792, 49.4186592, 8.6767921],
            [49.418641, 8.6767921, 49.4186592, 8.6767922],
            [49.418641, 8.6767922, 49.4186592, 8.6767923],
            [49.418641, 8.6767923, 49.4186592, 8.6769047],
            [49.418641, 8.6769047, 49.4186592, 8.6769152],
            [49.418641, 8.6769152, 49.4186592, 8.6769297],
            [49.418641, 8.6769297, 49.4186592, 8.6769648],
            [49.418641, 8.6769648, 49.4186592, 8.6769663],
            [49.418641, 8.6769663, 49.4186592, 8.6769928],
            [49.418641, 8.6769928, 49.4186592, 8.6769931],
            [49.418641, 8.6769931, 49.4186592, 8.677017],
            [49.418641, 8.677017, 49.4186592, 8.6770397],
            [49.4186592, 8.6767686, 49.4187137, 8.6767687],
            [49.4186592, 8.6767687, 49.4187137, 8.6767689],
            [49.4186592, 8.6767689, 49.4187137, 8.6767691],
            [49.4186592, 8.6767691, 49.4187137, 8.6767699],
            [49.4186592, 8.6767699, 49.4187137, 8.6767803],
            [49.4186592, 8.6767803, 49.4187137, 8.676792],
            [49.4186592, 8.676792, 49.4187137, 8.6767921],
            [49.4186592, 8.6767921, 49.4187137, 8.6767922],
            [49.4186592, 8.6767922, 49.4187137, 8.6767923],
            [49.4186592, 8.6767923, 49.4187137, 8.6769047],
            [49.4186592, 8.6769047, 49.4187137, 8.6769152],
            [49.4186592, 8.6769152, 49.4187137, 8.6769297],
            [49.4186592, 8.6769297, 49.4187137, 8.6769648],
            [49.4186592, 8.6769648, 49.4187137, 8.6769663],
            [49.4186592, 8.6769663, 49.4187137, 8.6769928],
            [49.4186592, 8.6769928, 49.4187137, 8.6769931],
            [49.4186592, 8.6769931, 49.4187137, 8.677017],
            [49.4186592, 8.677017, 49.4187137, 8.6770397],
            [49.4187137, 8.6767686, 49.4187142, 8.6767687],
            [49.4187137, 8.6767687, 49.4187142, 8.6767689],
            [49.4187137, 8.6767689, 49.4187142, 8.6767691],
            [49.4187137, 8.6767691, 49.4187142, 8.6767699],
            [49.4187137, 8.6767699, 49.4187142, 8.6767803],
            [49.4187137, 8.6767803, 49.4187142, 8.676792],
            [49.4187137, 8.676792, 49.4187142, 8.6767921],
            [49.4187137, 8.6767921, 49.4187142, 8.6767922],
            [49.4187137, 8.6767922, 49.4187142, 8.6767923],
            [49.4187137, 8.6767923, 49.4187142, 8.6769047],
            [49.4187137, 8.6769047, 49.4187142, 8.6769152],
            [49.4187137, 8.6769152, 49.4187142, 8.6769297],
            [49.4187137, 8.6769297, 49.4187142, 8.6769648],
            [49.4187137, 8.6769648, 49.4187142, 8.6769663],
            [49.4187137, 8.6769663, 49.4187142, 8.6769928],
            [49.4187137, 8.6769928, 49.4187142, 8.6769931],
            [49.4187137, 8.6769931, 49.4187142, 8.677017],
            [49.4187137, 8.677017, 49.4187142, 8.6770397],
            [49.4187142, 8.6767686, 49.4187206, 8.6767687],
            [49.4187142, 8.6767687, 49.4187206, 8.6767689],
            [49.4187142, 8.6767689, 49.4187206, 8.6767691],
            [49.4187142, 8.6767691, 49.4187206, 8.6767699],
            [49.4187142, 8.6767699, 49.4187206, 8.6767803],
            [49.4187142, 8.6767803, 49.4187206, 8.676792],
            [49.4187142, 8.676792, 49.4187206, 8.6767921],
            [49.4187142, 8.6767921, 49.4187206, 8.6767922],
            [49.4187142, 8.6767922, 49.4187206, 8.6767923],
            [49.4187142, 8.6767923, 49.4187206, 8.6769047],
            [49.4187142, 8.6769047, 49.4187206, 8.6769152],
            [49.4187142, 8.6769152, 49.4187206, 8.6769297],
            [49.4187142, 8.6769297, 49.4187206, 8.6769648],
            [49.4187142, 8.6769648, 49.4187206, 8.6769663],
            [49.4187142, 8.6769663, 49.4187206, 8.6769928],
            [49.4187142, 8.6769928, 49.4187206, 8.6769931],
            [49.4187142, 8.6769931, 49.4187206, 8.677017],
            [49.4187142, 8.677017, 49.4187206, 8.6770397],
            [49.4187206, 8.6767686, 49.4187207, 8.6767687],
            [49.4187206, 8.6767687, 49.4187207, 8.6767689],
            [49.4187206, 8.6767689, 49.4187207, 8.6767691],
            [49.4187206, 8.6767691, 49.4187207, 8.6767699],
            [49.4187206, 8.6767699, 49.4187207, 8.6767803],
            [49.4187206, 8.6767803, 49.4187207, 8.676792],
            [49.4187206, 8.676792, 49.4187207, 8.6767921],
            [49.4187206, 8.6767921, 49.4187207, 8.6767922],
            [49.4187206, 8.6767922, 49.4187207, 8.6767923],
            [49.4187206, 8.6767923, 49.4187207, 8.6769047],
            [49.4187206, 8.6769047, 49.4187207, 8.6769152],
            [49.4187206, 8.6769152, 49.4187207, 8.6769297],
            [49.4187206, 8.6769297, 49.4187207, 8.6769648],
            [49.4187206, 8.6769648, 49.4187207, 8.6769663],
            [49.4187206, 8.6769663, 49.4187207, 8.6769928],
            [49.4187206, 8.6769928, 49.4187207, 8.6769931],
            [49.4187206, 8.6769931, 49.4187207, 8.677017],
            [49.4187206, 8.677017, 49.4187207, 8.6770397]]
    }

    useEffect(() => {
        if (!data || !data.features) return;

        const processedData = data.features.map((feature) => {
            const { geometry, properties } = feature;
            const { relations } = properties;
            const coords = geometry.coordinates;

            const levelRelation = relations.find(rel => rel.reltags?.level);
            const floorLevel = levelRelation ? levelRelation.reltags.level : "unknown";

            return {
                id: feature.id,
                type: properties.tags?.buildingpart || "unknown",
                name: properties.tags?.name || "Unnamed",
                height: parseFloat(properties.tags?.height) || 0,
                width: parseFloat(properties.tags?.width) || 0,
                geometryType: geometry.type,
                level: floorLevel,
                coordinates:
                    geometry.type === "Polygon" ? coords[0].map(([lng, lat]) => [lat, lng]) :
                        geometry.type === "LineString" ? coords.map(([lng, lat]) => [lat, lng]) :
                            geometry.type === "Point" ? [coords[1], coords[0]] : null,
            };
        }).filter((feature) => feature.coordinates);

        const uniqueFloors = [...new Set(processedData.map(feature => feature.level))];

        console.log(setCooridorPath(processedData.filter((feature) => feature.type == "corridor"))
        )
        setCooridorPath(processedData.filter((feature) => feature.type == "corridor" && feature.level == 0))
        setFloors(uniqueFloors);
        setSelectedFloor(uniqueFloors[1]);
        setMapData(processedData);
        console.log("processed data", cooridorPath);
    }, [data]);
    useEffect(() => {
        // Reset moving marker position if a new path is set
        console.log("pathcoordinates ", pathCoordinates)
        if (pathCoordinates.length > 0) {
            setMovingMarkerPosition(pathCoordinates[0]);
            setCurrentPathIndex(0);
        }
    }, [pathCoordinates]);

    useEffect(() => {
        if (pathCoordinates.length === 0) return;

        // Create interval to update moving marker position
        const interval = setInterval(() => {
            setCurrentPathIndex((prevIndex) => {
                const nextIndex = prevIndex + 1;

                // If at the end of path, stop the interval
                if (nextIndex >= pathCoordinates.length) {
                    clearInterval(interval);
                    return prevIndex; // Keeps the marker at the end of the path
                }

                // Move the marker to the next coordinate on the path
                setMovingMarkerPosition(pathCoordinates[nextIndex]);
                return nextIndex;
            });
        }, 1000); // Move every 0.5 seconds

        // Clean up the interval on component unmount or path change
        return () => clearInterval(interval);
    }, [pathCoordinates]);

    const calculateCentroid = (coordinates) => {
        let centroid = [0, 0];
        const length = coordinates.length;

        coordinates.forEach(([lat, lng]) => {
            centroid[0] += lat;
            centroid[1] += lng;
        });

        centroid[0] /= length;
        centroid[1] /= length;

        return centroid;
    };

    const handleSearchChange = (e) => {
        const query = e.target.value.toLowerCase();
        setSearchQuery(query);

        const matchedFeatures = mapData.filter(
            feature => feature.level === selectedFloor && feature.name.toLowerCase().includes(query)
        );

        const newMarkerPositions = matchedFeatures.map(feature => ({
            coordinates: feature.geometryType === "Polygon"
                ? calculateCentroid(feature.coordinates)
                : feature.coordinates[0],
            name: feature.name,
        }));

        setMarkerPositions(newMarkerPositions);
    };

    const handleMarkerClick = (marker) => {
        console.log("Marker clicked:", marker);

        if (!srcMarker) {
            setSrcMarker(marker);
        } else if (!destMarker) {
            setDestMarker(marker);
            calculatePath(marker); // Calculate path once both src and dest are set
        }
    };

    // Function to calculate the nearest point on a corridor for a given source/destination
    const findNearestCorridorPoint = (source, corridor) => {
        let minDistance = Infinity;
        let nearestPoint = null;

        corridor.coordinates.forEach(([lat, lng]) => {
            const distance = Math.sqrt(
                Math.pow(lat - source[0], 2) + Math.pow(lng - source[1], 2)
            );
            if (distance < minDistance) {
                minDistance = distance;
                nearestPoint = [lat, lng];
            }
        });
        return nearestPoint;
    };

    const calculatePath = (destination) => {
        if (!srcMarker || !destination) return;

        // Filter corridors only on the selected floor
        const corridors = mapData.filter(
            (feature) => feature.type === "corridor" && feature.level === selectedFloor
        );

        // Find the closest corridor point to the srcMarker
        const srcCoords = srcMarker.coordinates;
        const destCoords = destination.coordinates;

        const findClosestCorridor = (point, corridors) => {
            let closestCorridor = null;
            let minDistance = Infinity;

            corridors.forEach((corridor) => {
                corridor.coordinates.forEach((coord) => {
                    const distance = Math.sqrt(
                        (point[0] - coord[0]) ** 2 + (point[1] - coord[1]) ** 2
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCorridor = coord;
                    }
                });
            });

            return closestCorridor;
        };

        const srcCorridorPoint = findClosestCorridor(srcCoords, corridors);
        const destCorridorPoint = findClosestCorridor(destCoords, corridors);

        if (!srcCorridorPoint || !destCorridorPoint) {
            console.log("No valid path found between source and destination.");
            return;
        }

        // Calculate the path by connecting srcCorridorPoint, corridors, and destCorridorPoint
        const path = [srcCoords, srcCorridorPoint, ...corridors.flatMap(corridor => corridor.coordinates), destCorridorPoint, destCoords];

        setPathCoordinates(path);
    };


    const handleFloorChange = (e) => {
        setSelectedFloor(e.target.value);
    };

    const getColorByType = (type) => {
        switch (type) {
            case "room": return "#f5e6b1";
            case "hall": return "#d4c7a1";
            case "corridor": return "#e0e0e0";
            case "verticalpassage": return "#d9b38c";
            case "shell": return "#c0c0c0";
            default: return "#8fc0e9";
        }
    };
    const calculateArcPoints = (center, radius, startAngle, endAngle, numPoints = 5) => {
        const points = [];
        const angleIncrement = (endAngle - startAngle) / numPoints;

        for (let i = 0; i <= numPoints; i++) {
            const angle = startAngle + i * angleIncrement;
            const x = center[0] + radius * Math.cos(angle);
            const y = center[1] + radius * Math.sin(angle);
            points.push([x, y]);
        }
        console.log("arc ",points)
        console.log("test ",testdata.coordinates)

        return points;
    };

    // Use this in your component where you want to render the arc
    const center = [49.4185603, 8.677043]; // Replace with the center coordinates of the room
    const radius = 0.00001; // Radius in degrees (adjust as needed for your map scale)
    const startAngle = -0.30; // Start angle in radians
    const endAngle = Math.PI + 0.3; // End angle in radians (e.g., 90 degrees here)

    // const arcPoints = calculateArcPoints(center, radius, startAngle, endAngle);
    function transformCoordinates(testdata) {
        let arr = []
        testdata.coordinates.map(([latStart, lonStart, latEnd, lonEnd]) => {
            arr.push([latStart,lonStart])
            arr.push([latEnd,lonEnd])
        })
        console.log("arr",arr)
        return arr
    }
    const arcPoints = transformCoordinates(testdata)
    console.log("new points ",arcPoints)

    return (
        <div>
            <input
                type="text"
                value={searchQuery}
                onChange={handleSearchChange}
                placeholder="Search by name"
            />
            <select onChange={handleFloorChange} value={selectedFloor || ""}>
                {floors.map(floor => (
                    <option key={floor} value={floor || 1}>
                        Floor {floor}
                    </option>
                ))}
            </select>

            <MapContainer center={[49.4185603, 8.677043]} zoom={18} style={{ height: "80vh", width: "100%" }}>
                {mapData
                    .filter(feature => feature.level === selectedFloor)
                    .map((feature, index) => {
                        const color = getColorByType(feature.type);
                        if (index === 0) {
                            const center = feature.coordinates[0];  // Assuming the first coordinate as the center
                            const radius = 5; // Set radius for the room circle

                            return (
                                < >
                                    {arcPoints.map((coord) => {
                                        return (
                                            <Marker
                                                position={coord}
                                                icon={L.divIcon({
                                                    className: 'moving-marker-icon',
                                                    html: `<div style="background-color: black; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                                                })}
                                            >
                                                <Tooltip>
                                                    <div>
                                                        <p>Coor: {coord[0]},{coord[1]}</p>
                                                    </div>
                                                </Tooltip>
                                            </Marker>

                                        )
                                    })}
                                </>
                            );

                        }

                        if (feature.geometryType === "Polygon") {
                            return (
                                <Polygon
                                    key={feature.id}
                                    positions={feature.coordinates}
                                    color="grey"
                                    fillColor={color}
                                    fillOpacity={0.7}
                                    weight={1}
                                >
                                    <Tooltip>
                                        <div>
                                            <h3>{feature.name}</h3>
                                            <p>Type: {feature.type}</p>
                                            <p>Height: {feature.height}m</p>
                                            <p>Floor: {feature.level}</p>
                                        </div>
                                    </Tooltip>
                                    {
                                        feature.coordinates.map((coord) => {
                                            return (
                                                <Marker
                                                    position={coord}
                                                    icon={L.divIcon({
                                                        className: 'moving-marker-icon',
                                                        html: `<div style="background-color: red; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                                                    })}
                                                >
                                                    <Tooltip>
                                                        <div>
                                                            <p>Coor: {coord[0]},{coord[1]}</p>
                                                        </div>
                                                    </Tooltip>
                                                </Marker>

                                            )
                                        })
                                    }
                                </Polygon>
                            );
                        } if (feature.geometryType === "LineString") {
                            return (
                                <Polyline
                                    key={feature.id}
                                    positions={feature.coordinates}
                                    color="#3498db"
                                    weight={4}
                                >
                                    <Tooltip>
                                        <div>
                                            <h3>{feature.name}</h3>
                                            <p>Type: {feature.type}</p>
                                            <p>Height: {feature.height}m</p>
                                            <p>Floor: {feature.level}</p>
                                        </div>
                                    </Tooltip>
                                    {
                                        feature.coordinates.map((coord) => {
                                            return (
                                                <Marker
                                                    position={coord}
                                                    icon={L.divIcon({
                                                        className: 'moving-marker-icon',
                                                        html: `<div style="background-color: red; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                                                    })}
                                                >
                                                    <Tooltip>
                                                        <div>
                                                            <p>Coor: {coord[0]},{coord[1]}</p>
                                                        </div>
                                                    </Tooltip>
                                                </Marker>

                                            )
                                        })
                                    }

                                </Polyline>
                            );
                        } if (feature.geometryType === "Point") {
                            return (
                                <Marker
                                    key={feature.id}
                                    position={feature.coordinates}
                                    icon={L.divIcon({
                                        className: 'custom-icon',
                                        html: `<div style="background-color:${color}; width:8px; height:4px;"></div>`
                                    })}
                                    eventHandlers={{
                                        click: () => handleMarkerClick(feature)
                                    }}
                                >
                                    <Tooltip>
                                        <div>
                                            <h3>{feature.name}</h3>
                                            <p>Type: {feature.type}</p>
                                            <p>Height: {feature.height}m</p>
                                            <p>Width: {feature.width}m</p>
                                            <p>Floor: {feature.level}</p>
                                        </div>
                                    </Tooltip>

                                    <Marker
                                        position={feature.coordinates}
                                        icon={L.divIcon({
                                            className: 'moving-marker-icon',
                                            html: `<div style="background-color: red; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                                        })}
                                    />
                                </Marker>
                            );
                        }
                        {
                            testdata.coordinates.map((coord, index) => (
                                <Marker
                                    key={index}
                                    position={coord}
                                    icon={L.divIcon({
                                        className: 'moving-marker-icon',
                                        html: `<div style="background-color: blue; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                                    })}
                                >
                                    <Tooltip>
                                        <div>
                                            <p>Coor: {coord[0]}, {coord[1]}</p>
                                        </div>
                                    </Tooltip>
                                </Marker>
                            ))
                        }





                        return null;
                    })}

                {/* Render markers for search results */}
                {/* {
                    cooridorPath.map((coord) => {
                        return (
                            <Marker
                                position={coord.coordinates}
                                icon={L.divIcon({
                                    className: 'moving-marker-icon',
                                    html: `<div style="background-color: red; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                                })}
                            >
                                <Tooltip>
                                    <div>
                                        <p>Coor: {coord[0]},{coord[1]}</p>
                                    </div>
                                </Tooltip>
                            </Marker>

                        )
                    })
                } */}
                {/* {cooridorPath.map((marker, index) => (
                    <Marker
                        key={index}
                        position={marker.coordinates}
                        icon={L.divIcon({
                            className: 'custom-icon',
                            html: `<div style="
                                        background-color: ${marker === srcMarker ? 'green' : marker === destMarker ? 'red' : 'white'};
                                        padding: 4px; 
                                        color:${marker === srcMarker ? 'white' : marker === destMarker ? 'white' : 'black'};
                                        width: auto; 
                                        height: auto; 
                                        display: inline-block; 
                                        border-radius: 4px; 
                                        text-align: center; 
                                        font-size: 12px;">
                                        ${marker.name}
                                    </div>`
                        })}


                        eventHandlers={{
                            click: () => handleMarkerClick(marker)
                        }}
                    >

                    </Marker>
                ))} */}

                {/* Render the path from src to dest */}
                {pathCoordinates.length > 0 && (
                    <Polyline positions={pathCoordinates} color="blue" weight={3} />
                )}

                {movingMarkerPosition && (
                    <Marker
                        position={movingMarkerPosition}
                        icon={L.divIcon({
                            className: 'moving-marker-icon',
                            html: `<div style="background-color: red; width: 10px; height: 10px; border-radius: 50%;"></div>`,
                        })}
                    />
                )}

            </MapContainer>

        </div >
    );
};

export default IndoorMap;






//3d structure

// import React, { useState, useEffect, useMemo } from 'react';
// import { Canvas } from '@react-three/fiber';
// import { OrbitControls, Line, Text } from '@react-three/drei';
// import { Card, CardContent } from '@mui/material'; // Use MUI for Card and CardContent
// import { Select, MenuItem, FormControl, InputLabel, Select as MuiSelect } from '@mui/material'; // MUI Select components

// const Box = ({ position, size, color, name }) => {
//     return (
//         <group position={position}>
//             <mesh>
//                 <boxGeometry args={size} />
//                 <meshStandardMaterial color={color} />
//             </mesh>
//             {name && (
//                 <Text
//                     position={[0, size[1] + 0.5, 0]}
//                     fontSize={1}
//                     color="black"
//                     anchorX="center"
//                     anchorY="middle"
//                 >
//                     {name}
//                 </Text>
//             )}
//         </group>
//     );
// };

// const IndoorMap = ({ data }) => {
//     const [selectedFloor, setSelectedFloor] = useState(null);

//     // Process map data using useMemo to avoid unnecessary recalculations
//     const { mapData, floors, bounds } = useMemo(() => {
//         if (!data?.features) {
//             return { mapData: [], floors: [], bounds: null };
//         }

//         let minX = Infinity, maxX = -Infinity;
//         let minZ = Infinity, maxZ = -Infinity;

//         const processedData = data.features
//             .map((feature) => {
//                 const { geometry, properties } = feature;
//                 if (!geometry || !properties) return null;

//                 const levelRelation = properties.relations?.find(rel => rel.reltags?.level);
//                 const floorLevel = levelRelation ? levelRelation.reltags.level : "0";

//                 // Reduced scale factor
//                 const SCALE_FACTOR = 1;

//                 try {
//                     const coordinates = (() => {
//                         if (geometry.type === "Polygon" && geometry.coordinates?.[0]) {
//                             return geometry.coordinates[0].map(([lng, lat]) => {
//                                 const x = lat * SCALE_FACTOR;
//                                 const z = lng * SCALE_FACTOR;
//                                 minX = Math.min(minX, x);
//                                 maxX = Math.max(maxX, x);
//                                 minZ = Math.min(minZ, z);
//                                 maxZ = Math.max(maxZ, z);
//                                 return [x, z];
//                             });
//                         }
//                         if (geometry.type === "LineString" && geometry.coordinates) {
//                             return geometry.coordinates.map(([lng, lat]) => {
//                                 const x = lat * SCALE_FACTOR;
//                                 const z = lng * SCALE_FACTOR;
//                                 minX = Math.min(minX, x);
//                                 maxX = Math.max(maxX, x);
//                                 minZ = Math.min(minZ, z);
//                                 maxZ = Math.max(maxZ, z);
//                                 return [x, z];
//                             });
//                         }
//                         if (geometry.type === "Point" && geometry.coordinates) {
//                             const x = geometry.coordinates[1] * SCALE_FACTOR;
//                             const z = geometry.coordinates[0] * SCALE_FACTOR;
//                             minX = Math.min(minX, x);
//                             maxX = Math.max(maxX, x);
//                             minZ = Math.min(minZ, z);
//                             maxZ = Math.max(maxZ, z);
//                             return [[x, z]];
//                         }
//                         return null;
//                     })();

//                     if (!coordinates) return null;

//                     return {
//                         id: feature.id,
//                         type: properties.tags?.buildingpart || "unknown",
//                         name: properties.tags?.name || "",
//                         height: Math.max(parseFloat(properties.tags?.height) || 3, 1),
//                         width: Math.max(parseFloat(properties.tags?.width) || 4, 1),
//                         geometryType: geometry.type,
//                         level: floorLevel,
//                         coordinates
//                     };
//                 } catch (error) {
//                     console.error(`Error processing feature ${feature.id}:`, error);
//                     return null;
//                 }
//             })
//             .filter(Boolean);

//         const uniqueFloors = [...new Set(processedData.map(feature => feature.level))].sort((a, b) => parseFloat(a) - parseFloat(b));

//         return {
//             mapData: processedData,
//             floors: uniqueFloors,
//             bounds: { minX, maxX, minZ, maxZ }
//         };
//     }, [data]);

//     // Set initial floor when data loads
//     useEffect(() => {
//         if (floors.length && !selectedFloor) {
//             setSelectedFloor(floors[0]);
//         }
//     }, [floors, selectedFloor]);

//     const getColorByType = useMemo(() => ({
//         room: "#f5e6b1",
//         hall: "#d4c7a1",
//         corridor: "#e0e0e0",
//         verticalpassage: "#d9b38c",
//         shell: "#c0c0c0",
//         unknown: "#8fc0e9"
//     }), []);

//     // Calculate camera position based on bounds
//     const cameraPosition = useMemo(() => {
//         if (!bounds) return [0, 20, 30];
//         const centerX = (bounds.minX + bounds.maxX) / 2;
//         const centerZ = (bounds.minZ + bounds.maxZ) / 2;
//         const distance = Math.max(
//             Math.abs(bounds.maxX - bounds.minX),
//             Math.abs(bounds.maxZ - bounds.minZ)
//         );
//         return [centerX, distance, centerZ + distance];
//     }, [bounds]);

//     if (!data?.features) {
//         return <div className="p-4">No map data available</div>;
//     }

//     return (
//         <Card sx={{ width: '100%', height: '100%' }}>
//             <CardContent sx={{ p: 4 }}>
//                 <div className="mb-4">
//                     <FormControl fullWidth>
//                         <InputLabel>Select Floor</InputLabel>
//                         <MuiSelect
//                             value={selectedFloor}
//                             onChange={(e) => setSelectedFloor(e.target.value)}
//                             label="Select Floor"
//                         >
//                             {floors.map(floor => (
//                                 <MenuItem key={floor} value={floor}>
//                                     Floor {floor}
//                                 </MenuItem>
//                             ))}
//                         </MuiSelect>
//                     </FormControl>
//                 </div>

//                 <Box sx={{ width: '100%', height: 500 }}>
//                     <Canvas
//                         camera={{
//                             position: cameraPosition,
//                             fov: 50,
//                             near: 0.1,
//                             far: 1000
//                         }}
//                         style={{ width: '100%', height: '100%' }}
//                     >
//                         <ambientLight intensity={0.6} />
//                         <directionalLight position={[1, 1, 1]} intensity={0.6} />
//                         <OrbitControls
//                             enableDamping
//                             dampingFactor={0.05}
//                             target={[(bounds?.minX + bounds?.maxX) / 2 || 0, 0, (bounds?.minZ + bounds?.maxZ) / 2 || 0]}
//                         />

//                         {/* Debug grid */}
//                         <gridHelper args={[100, 100]} position={[0, 0, 0]} />

//                         {mapData
//                             .filter(feature => feature.level === selectedFloor)
//                             .map((feature) => {
//                                 const color = getColorByType[feature.type] || getColorByType.unknown;
//                                 const floorHeight = parseFloat(feature.level) * 3;

//                                 if (feature.geometryType === "Polygon" && feature.type !== "corridor") {
//                                     const [x, z] = feature.coordinates[0];
//                                     return (
//                                         <Box
//                                             key={feature.id}
//                                             position={[x, floorHeight, z]}
//                                             size={[feature.width, feature.height, feature.width]}
//                                             color={color}
//                                             name={feature.name}
//                                         />
//                                     );
//                                 }

//                                 if (feature.geometryType === "LineString" && feature.type === "corridor") {
//                                     const points = feature.coordinates.map(([x, z]) => [x, floorHeight, z]);
//                                     return (
//                                         <Line
//                                             key={feature.id}
//                                             points={points}
//                                             color={color}
//                                             lineWidth={2}
//                                         />
//                                     );
//                                 }

//                                 return null;
//                             })}
//                     </Canvas>
//                 </Box>
//             </CardContent>
//         </Card>
//     );
// };

// export default IndoorMap;


